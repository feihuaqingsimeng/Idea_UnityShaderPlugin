{
    parserClass="com.teng.parser.ShaderParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Shader"
    psiImplClassSuffix="Impl"
    psiPackage="com.teng.psi"
    psiImplPackage="com.teng.psi.impl"
    psiImplUtilClass="com.teng.psi.impl.ShaderPsiImplUtil"

    parserUtilClass = "com.teng.psi.ShaderParseUtil"
    elementTypeHolderClass="com.teng.psi.ShaderTypes"
    elementTypeClass="com.teng.psi.ShaderElementType"
    elementTypeFactory = "com.teng.Util.ShaderUtil.createType"
    tokenTypeClass="com.teng.psi.ShaderTokenType"
    tokenTypeFactory = "com.teng.Util.ShaderUtil.createToken"


    tokens = [
        OR = "||"
        AND = "&&"
        BREAK = "break"
        IF = "if"
        ELSE = "else"
        FOR = "for"
        IN = "in"
        OUT = "out"
        REGION = "REGION"
        ENDREGION = "ENDREGION"
        NOT = "!"

        EQ = "=="
        GE = ">="
        LE = "<="
        NE = "!="
        MINUS = "-"
        PLUS = "+"
        MULT = "*"
        MOD = "%"
        DIV = "/"
        ASSIGN = "="
        GT = ">"
        LT = "<"
        LPAREN = "("
        RPAREN = ")"
        LBRACKET = "["
        RBRACKET = "]"
        LCURLY = "{"
        RCURLY = "{"
        GETN = "#"
        COMMA = ","
        SEMI = ";"
        DOT = "."
        EXP = "^"

        BLOCK_COMMENT = "BLOCK_COMMENT"
        ID = "regexp:[A-Za-z_][A-Za-z0-9_]*"
        NUMBER = "NUMBER"
        STRING = "STRING"

        BIT_OR = "|"
        BIT_AND = "&"
        BIT_TILDE = "~"
        BIT_LTLT = "<<"
        BIT_RTRT = ">>"
    ]
}

shaderFile ::= stat_semi*

private stat_semi ::= stat_impl ';' ?

private stat_impl ::= property

expr ::= <<parseExpr primaryExpr closureExpr>>
{
    implements = [
        //"com.teng.psi.element.ShaderTypeGuessable"
    ]
}

binaryOp ::= '+' | '-' | '*' | '/' | '^' | '%' | '<' | '<=' | '>' | '>=' | '==' | '!=' | '&&' | '||'
    | '|' | '&' | '>>' | '<<' | '~'
left binaryExpr  ::= binaryOp expr
{
    pin = 1
    implements = [
    ]
}
unaryOp ::= '-' | '!'
unaryExpr ::= unaryOp (unaryExpr )
/*private primaryExpr ::= prefixExpr(suffixExpr*)
private prefixExpr ::= parenExpr | nameExpr | literalExpr| tableExpr
private suffixExpr ::= indexExpr | callExpr

parenExpr ::= '(' expr ')'
{

}
nameExpr ::= ID
{

}
literalExpr ::= null | false | true | NUMBER |STRING {

}
tableExpr ::= '{'fieldList '}'
{

}
left indexExpr ::= '[' expr ']' | '.' ID
{

}
left callExpr ::= args {

}
closureExpr ::= 'function' funcBody{

}
*/
ifStat ::= 'if' ID 'then' ID 'end'{}

property ::= (KEY? SEPARATOR VALUE?) | KEY | COMMENT|CRLF |binaryOp